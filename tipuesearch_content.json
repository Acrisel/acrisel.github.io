{"pages":[{"text":"\n\n\n\nAcrisel's Community Blog\n\n\n\n\n\n\n      body {\n        padding-top: 60px;\n        padding-bottom: 40px;\n      }\n      .sidebar-nav {\n        padding: 9px 0;\n      }\n      .tag-1 {\n        font-size: 13pt;\n      }\n      .tag-2 {\n        font-size: 10pt;\n      }\n      .tag-2 {\n        font-size: 8pt;\n      }\n      .tag-4 {\n        font-size: 6pt;\n     }\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAcrisel's Community Blog \n\n\n\n\n\ninformation\n\t\t\t\t\t\n\n\n\n08\n\t\t\t\t\t\n\n\n\n07\n\t\t\t\t\t\n\n\nArchives\n\n\n\n\n\n\n\n\n\n\n\nAcrisel's Place\n\nWellcome\nThis place was designed to allow the Acrisel Team and its partners to have open conversation.\nIt is intended to share experiences and can benefit everyone.\nThank you for visiting!\n\n\n\n\n\nblogroll\nAcrisel\nAcrisel Open Source\nPelican\nPython.org\nJinja2\nCategories\n\n\ninformation\n\n\n\n\n08\n\n\n\n\n07\n\n\nTags\n \n\n\n\n\n                Proudly powered by Pelican ,\n                                which takes great advantage of Python .\n        \nThe theme is from Bootstrap from Twitter ,\n                   and Font-Awesome , thanks!\nCopyright Â© 2017 Acrisel \n\n\n\n\n\n\n\n","tags":"","url":"https://acrisel.github.io/index.html","title":"Acrisel's Community Blog"},{"text":"Ordered Class Maintain Ordered of Fields in Class Introduction We saw many questions on the WEB regarding having Python class maintain order of its fields. Reason being that __dict__ is dict, therefore, class doesn't register the order of the fields presented to it. We decided to share our version of such a class. We use OrderedClass were we need to maintain record like structure. Such that when we package the record, it always packages the fields in the same order. It is also useful when comparing fields between objects. Having fields being printed out in the same order is very useful. Keep in mind that without using OrderedDict, object __dict__ will print in order. However, Python does not guarantee that order. When using OrderedDict instead, order is guaranteed. OrderedClass Using metaclass features of Python we can simply override __prepare__ returning OrderedDict object. 1 2 3 4 5 6 7 8 9 from collections import OrderedDict class OrderedClassMeta ( type ): @classmethod def __prepare__ ( cls , name , bases , ** kwds ): return OrderedDict () class OrderedClass ( metaclass = OrderedClassMeta ): pass Example use To use, we just inherent from OrderedClass instead of object. 1 2 3 4 5 6 7 8 9 class A ( OrderedClass ): def __init__ ( self ): self . b = 1 self . a = 2 class B ( OrderedClass ): def __init__ ( self ): self . a = 1 self . b = 2 Examine Output Printing the dictionaries of the above examples. 1 2 3 4 a = A () print ( a . __dict__ ) b = B () print ( b . __dict__ ) 1 2 { 'b' : 1 , 'a' : 2 } { 'a' : 1 , 'b' : 2 } References Python PEP 520 Give us your feedback: support@acrisel.com Visit us at our home","tags":"08","url":"posts/2017/08/ordered-class/","title":"Ordered Class"},{"text":"Print Directory Tree Mimicking Linux Tree Utility Introduction Many blogs are showing how to print directory tree using Python. Drawing from those examples, we built our version. The primary drivers were: Compatibility with Python3 Print symbolic links Limit depth of tree Function Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import os def realname ( path , root = None ): if root is not None : path = os . path . join ( root , path ) result = os . path . basename ( path ) if os . path . islink ( path ): realpath = os . readlink ( path ) result = ' %s -> %s ' % ( os . path . basename ( path ), realpath ) return result def ptree ( startpath , depth =- 1 ): prefix = 0 if startpath != '/' : if startpath . endswith ( '/' ): startpath = startpath [: - 1 ] prefix = len ( startpath ) for root , dirs , files in os . walk ( startpath ): level = root [ prefix :] . count ( os . sep ) if depth >- 1 and level > depth : continue indent = subindent = '' if level > 0 : indent = '| ' * ( level - 1 ) + '|-- ' subindent = '| ' * ( level ) + '|-- ' print ( '{}{}/' . format ( indent , realname ( root ))) # print dir only if symbolic link; otherwise, will be printed as root for d in dirs : if os . path . islink ( os . path . join ( root , d )): print ( '{}{}' . format ( subindent , realname ( d , root = root ))) for f in files : print ( '{}{}' . format ( subindent , realname ( f , root = root ))) I will refrain from going over the code, otherwise self-explanatory, except mentioning the following: os.walk treats symbolic links per their target. Therefore, a symbolic link may appear in dirs and files. only two main features of tree are replicated: accepting both a root path and depth to explore. Command line Arguments Command line arguments is simple and self explanatory ... 1 2 3 4 5 6 7 8 9 10 11 if __name__ == '__main__' : import argparse parser = argparse . ArgumentParser ( description = 'prints directory tree.' ) parser . add_argument ( '--level' , '-l' , type = int , dest = 'depth' , help = 'depth of tree to print' ) parser . add_argument ( 'startpath' , type = str , help = 'path to stating directory' ) args = parser . parse_args () argsd = vars ( args ) ptree ( ** argsd ) References ptree.py can be download from github Give us your feedback: support@acrisel.com Visit us at our home","tags":"08","url":"posts/2017/08/print-directory-tree/","title":"Print Directory Tree"},{"text":"Thinking about Cobol Conversion? Acrisel team has vast experience in Cobol conversion. We are sharing this knowledge with our community. Introduction Cobol is a structural language with many years of maturity. It was built for business use, and it is used as that for a few decades now. So why to move away from it? Let's start with that Cobol is a great language with many features for data processing. It is used in many core business processes. So core and critical that companies afraid to touch it due to the risk of impairing their business. Cobol has a solid environment for development, test, and run since late 50's. So really, why to convert? There is plenty of information with conflicting advice to either stay with or move out of Cobol. Rather try to weigh in on such discussion, here are a few drivers that lead companies to consider moving on. In reality, stay or convert is a business investment with long term vision. As such, it needs to be incorporated into your company's long-term business goals and objectives. Continue reading : Thinking on Cobol Conversion . Give us your feedback: support@acrisel.com Visit us at our home","tags":"07","url":"posts/2017/07/cobol-conversion-take-1/","title":"Cobol Conversion Take 1"},{"text":"Welcome U'All Welcome to Acrilse community blog. The Acrisel Team will keep the blog updated with latest expeircens in different domains of software engineering. The Acrisel Team reserves the right to suprise us with posts from other areas of life that the team finds interesting. You can contact us ar support@acrisel.com Visti our website: http://www.acrisel.com Keep tuned.","tags":"information","url":"posts/2017/07/welcome-all/","title":""}]}