{"pages":[{"text":"\n\n\n\nAcrisel's Community Blog\n\n\n\n\n\n\n      body {\n        padding-top: 60px;\n        padding-bottom: 40px;\n      }\n      .sidebar-nav {\n        padding: 9px 0;\n      }\n      .tag-1 {\n        font-size: 13pt;\n      }\n      .tag-2 {\n        font-size: 10pt;\n      }\n      .tag-2 {\n        font-size: 8pt;\n      }\n      .tag-4 {\n        font-size: 6pt;\n     }\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAcrisel's Community Blog \n\n\n\n\n\ninformation\n\t\t\t\t\t\n\n\n\n08\n\t\t\t\t\t\n\n\n\n07\n\t\t\t\t\t\n\n\nArchives\n\n\n\n\n\n\n\n\n\n\n\nAcrisel's Place\n\nWellcome\nThis place was designed to allow the Acrisel Team and its partners to have open conversation.\nIt is intended to share experiences and can benefit everyone.\nThank you for visiting!\n\n\n\n\n\nblogroll\nAcrisel\nAcrisel Open Source\nPelican\nPython.org\nJinja2\nCategories\n\n\ninformation\n\n\n\n\n08\n\n\n\n\n07\n\n\nTags\n \n\n\n\n\n                Proudly powered by Pelican ,\n                                which takes great advantage of Python .\n        \nThe theme is from Bootstrap from Twitter ,\n                   and Font-Awesome , thanks!\n\n\n\n\n\n\n\n","url":"https://acrisel.github.io/index.html","title":"Acrisel's Community Blog","tags":""},{"text":"Print Directory Tree Mimicking Linux Tree Utility Introduction Many blogs are showing how to print directory tree using Python. Drawing from those examples, we built our version. The primary drivers were: Compatability with Python3 Print symbolic links Limit depth of tree Function Code I will refrain from going over the code, otherwise self-explanatory, except mentioning the following: os.walk treats symbolic links per their target. Therefore, a symbolic link may appear in dirs and files. only two main features of tree are replicated: accepting both a root path and depth to explore. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import os def realname ( path , root = None ): ''' joins root with path, if root is provided. Then check is it is a symlink. If it is, return a string representing the link. Otherwise, return basename or path. ''' if root is not None : path = os . path . join ( root , path ) result = os . path . basename ( path ) if os . path . islink ( path ): realpath = os . readlink ( path ) result = ' %s -> %s ' % ( os . path . basename ( path ), realpath ) return result def ptree ( startpath , depth =- 1 ): ''' prints directory tree in 'tree' structure. Args: startpath: root path to start depth: depth of tree to print; default: -1 which signals not limit ''' prefix = 0 if startpath != '/' : if startpath . endswith ( '/' ): startpath = startpath [: - 1 ] prefix = len ( startpath ) for root , dirs , files in os . walk ( startpath ): level = root [ prefix :] . count ( os . sep ) if depth >- 1 and level > depth : continue indent = subindent = '' if level > 0 : indent = '| ' * ( level - 1 ) + '|-- ' subindent = '| ' * ( level ) + '|-- ' print ( '{}{}/' . format ( indent , realname ( root ))) # print dir only if symbolic link; otherwise, will be printed as root for d in dirs : if os . path . islink ( os . path . join ( root , d )): print ( '{}{}' . format ( subindent , realname ( d , root = root ))) for f in files : print ( '{}{}' . format ( subindent , realname ( f , root = root ))) Command line Arguments Command line arguments, 1 2 3 4 5 6 7 8 9 if __name__ == '__main__' : import argparse parser = argparse . ArgumentParser ( description = \"\"\"prints directory tree.\"\"\" ) parser . add_argument ( '--level' , '-l' , type = int , dest = 'depth' , help = 'depth of tree to print' ) parser . add_argument ( 'startpath' , type = str , help = 'path to stating directory' ) args = parser . parse_args () argsd = vars ( args ) ptree ( ** argsd ) References ptree.py can be download from github Give us your feedback: support@acrisel.com","url":"posts/2017/08/print-directory-tree/","title":"Print Directory Tree","tags":"08"},{"text":"Thinking about Cobol Conversion? Acrisel team has vast experience in Cobol conversion. We are sharing this knowledge with our community. Introduction Cobol is a structural language with many years of maturity. It was built for business use, and it is used as that for a few decades now. So why to move away from it? Let's start with that Cobol is a great language with many features for data processing. It is used in many core business processes. So core and critical that companies afraid to touch it due to the risk of impairing their business. Cobol has a solid environment for development, test, and run since late 50's. So really, why to convert? There is plenty of information with conflicting advice to either stay with or move out of Cobol. Rather try to weigh in on such discussion, here are a few drivers that lead companies to consider moving on. In reality, stay or convert is a business investment with long term vision. As such, it needs to be incorporated into your company's long-term business goals and objectives. Continue reading : Thinking on Cobol Conversion . Give us your feedback: support@acrisel.com","url":"posts/2017/07/cobol-conversion-take-1/","title":"Cobol Conversion Take 1","tags":"07"},{"text":"Welcome U'All Welcome to Acrilse community blog. The Acrisel Team will keep the blog updated with latest expeircens in different domains of software engineering. The Acrisel Team reserves the right to suprise us with posts from other areas of life that the team finds interesting. You can contact us ar support@acrisel.com Visti our website: http://www.acrisel.com Keep tuned.","url":"posts/2017/07/welcome-all/","title":"","tags":"information"}]}